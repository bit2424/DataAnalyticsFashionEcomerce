# -*- coding: utf-8 -*-
"""imagenes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LeQM3Hm8GNwBglR_BH8UanPKBRDmW9pK
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

import keras
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D
#from keras.utils import to_categorical
from keras.preprocessing import image

import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from tqdm import tqdm

import pickle

df = pd.read_csv("../Resources/Datasets/summer-products.csv")
unique_categories_df = pd.read_csv("../Resources/Datasets/unique-categories.csv")
#/summer-products-with-rating-and-performance_2020-08.csv
print("Dataset principal")
print(df.columns)
print("\n")
print(df.shape)
print("\nUnique categories")
print(unique_categories_df.columns)
print("\n")
print(unique_categories_df.shape)
#https://www.kaggle.com/jmmvutu/summer-products-and-sales-in-ecommerce-wish

unique_categories_df.head()

"""### Descargamos las imagenes"""

#file = open("Imagene/" + url.split('/')[-1], "wb")


"""## Poner los tags con valores booleanos"""

lista_dummy = np.array([0]*df.shape[0])
esperado = pd.DataFrame()
len(lista_dummy)
for categoria in unique_categories_df['tag']:
  for i in range(len(lista_dummy)):
    lista_dummy[i] = categoria in df['tags'][i].split(",")
  df[categoria] = lista_dummy
  esperado[categoria] = lista_dummy

print(df.shape)



"""## Ahora a cargar las imagenes de forma apropiada para entrenar el modelo

### Importamos librerias de clasificacion de imagenes con redes neuronales y otras utiles
"""

import urllib.request as urlb
import matplotlib.pyplot as plt
train_image = []
df['product_picture_name'] = lista_dummy
for i in tqdm(range(df.shape[0])):
    picture = df['product_picture'][i].split('/')[-1]
    df['product_picture_name'][i] = picture
    img = image.load_img("../Resources/Images/" + picture,target_size=(200,200,3))
    img = image.img_to_array(img)
    img = img/255
    train_image.append(img)
X = np.array(train_image)
#X = X.astype(np.float32)
y = np.array(esperado)

"""## Partimos en conjunto de entrenamiento y de pruebas"""

from sklearn.model_selection import train_test_split
from copy import deepcopy

trainig_size = 0.6
testing_size = 1-trainig_size
random_seed = 42

# arreglamos algunas cosas para que el modelo vaya bien
#esperado = np.asarray(esperado).astype(np.int64) # DESCOMENTALO SI RECAPACITAS XD

#X_train, X_test, y_train, y_test = train_test_split(X, esperado, test_size=testing_size, random_state=random_seed,shuffle=True)
#X_train, X_test, y_train, y_test = train_test_split(X, esperado, test_size=testing_size, random_state=random_seed) # CON ESTE DEBERIA FUNCIONAR
#X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=testing_size, random_state=random_seed)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=testing_size, random_state=random_seed, shuffle=True)

"""## Aqui se hace la magia"""

# The next step is to define the architecture of our model. The output layer will have 25 neurons (equal to the number of genres) and weâ€™ll use sigmoid as the activation function.

# I will be using a certain architecture (given below) to solve this problem. You can modify this architecture as well by changing the number of hidden layers, activation functions and other hyperparameters.

model = Sequential()
#model.add(Conv2D(filters=16, kernel_size=(5, 5), activation="relu", input_shape=(400,400,3)))
model.add(Conv2D(filters=16, kernel_size=(5, 5), activation="relu", input_shape=(200,200,3)))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))
model.add(Conv2D(filters=32, kernel_size=(5, 5), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))
model.add(Conv2D(filters=64, kernel_size=(5, 5), activation="relu"))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))
model.add(Conv2D(filters=64, kernel_size=(5, 5), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))
model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(64, activation='relu'))
model.add(Dropout(0.5))
#model.add(Dense(25, activation='sigmoid'))
model.add(Dense(unique_categories_df.shape[0], activation='sigmoid'))

# Vemos como quedo el modelo
model.summary()

"""## Entrenamiento del modelo"""

print(X_train.shape)
print(y_train.shape)
print(X_test.shape)
print(y_test.shape)

# compile and train
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model.fit(X_train, y_train, epochs=10, validation_data=(X_test, y_test), batch_size=64)


model_path = "../Resources/Persistence/imageModel.json"

with open(model_path, "w") as f:
    f.write(model.to_json())

weights_path = "../Resources/Persistence/imageWeights.h5"
model.save_weights(weights_path)


"""## Probamos"""

# test with an image

# load the image
thisimg = 1000
img = urlb.urlopen(df['product_picture'][1000]) # usar algo del conjunto de pruebas hagame el favor
img = plt.imread(img,0)
img = img/255

# test the image against the model and retrieve the top three genres
classes = np.array(esperado.columns)
proba = model.predict(img.reshape(1,200,200,3))
top_x = np.argsort(proba[0])[:-10:-1]
for i in range(len(top_x)):
    print("{}".format(classes[top_x[i]])+" ({:.3})".format(proba[0][top_x[i]]))
plt.imshow(img)

df['tags'][thisimg].split(",")